"""
    assemble_tbc(fv::FacetValues, dh::DofHandler, F::SparseMatrixCSC, facetset, dofsDtN, N, k, α)

Assemble the TBC matrix for the nonlinear eigenvalue problem.

# Arguments

- `fv`: `FacetValues`
- `dh`: `DofHandler`
- `F`: an empty sparse pattern for the TBC matrix
- `facetset`: `Facets` on the artificial boundary
- `dofsDtN`: Degrees of Freedom associated to the artificial boundary
- `N`: the number of the terms in the truncated DtN map
- `k`: the wavenumber
- `α`: the quasimomentum
"""
function assemble_tbc(fv::FacetValues, dh::DofHandler, F::SparseMatrixCSC, facetset, dofsDtN, N, k, α)
    # Allocate the vector Θ
    Θ = sparsevec(dofsDtN, zeros(ComplexF64, length(dofsDtN)), ndofs(dh))
    
    # Loop over truncated terms
    for n in -N:N 
        # Reset the vector Θ to zero
        fill!(Θ, 0.0 + 0.0im)
        
        # Compute βₙ 
        βₙ = beta_n(k, α, n)

        # Compute the vector Θ (Fourier coefficients and their conjugates)
        compute_coef!(fv, dh, facetset, Θ, n)
        
        # Assemble the TBC matrix
        for i in Θ.nzind, j in Θ.nzind
            v = im * βₙ * Θ[i] * conj(Θ[j])/(2π)
            Ferrite.addindex!(F, v, i, j)
        end
    end
    
    return F
end

"""
    my_sqrt(z::Complex{T}) where T<:AbstractFloat

Square root for complex numbers which takes the negative imaginary axis 
as the branch cut.
"""
function my_sqrt(z::Complex{T}) where T<:AbstractFloat
    # Handle special case of zero input
    if z == zero(z)
        return zero(z)
    end
    
    # Rotate by -π/2 (multiply by -i)
    rot_z = Complex(imag(z), -real(z))
    
    # Compute standard square root
    sqrt_rot = sqrt(rot_z)
    
    # Rotate by π/4 (multiply by exp(im * π/4))
    e = 1/sqrt(2)
    r = (real(sqrt_rot) - imag(sqrt_rot)) * e
    i = (real(sqrt_rot) + imag(sqrt_rot)) * e
    result = Complex(r, i)
    
    return result
end

# Convenience method for other number types
my_sqrt(z::Complex) = my_sqrt(float(z))

function beta_n(k, α, n)
    αₙ = α + complex(n)
    # βₙ = sqrt(complex(k)^2 - αₙ^2)
   βₙ = my_sqrt(complex(k)^2 - αₙ^2)
    
    return βₙ
end

"""
    Nnep{T}

Contain the information of the nonlinear eigenvalue problem (NEP) generated by 
the DtN-FEM. By the finite element discretization, we obtain

`` (\\mathbf{A}_{0} + \\alpha \\mathbf{A}_{1} + \\alpha^2 \\mathbf{A}_{2} + \\mathbf{F}(\\alpha)) \\mathbf{u} = 0. ``

We split the NEP into two parts: quadratic part and fully nonlinear part. For 
the quadraic part, we can decouple the `α` from the NEP easily. So the struct 
`Nnep` stores these three matrices directly. For the fully nonlinear part, `Nnep` 
just stores neccessary information for its finite element discretization.

# Fields

- `A₀`, `A₁`, `A₂`: the matrices associated to the quadratic part
- `fv`: `FacetValues` used for the integral on boundaries in Ferrite.jl
- `dh`: `DofHandler`
- `cst`: `ConstraintHandler` used for the information on boundary conditions
- `facetset`: the set of `Facets` on the artificial boundary
- `dofsDtN`: Degrees of Freedom associated to the artificial boundary
- `N`: the number of the terms in the truncated DtN map
- `k`: the wavenumber
"""
struct Nnep{T}
    A₀::SparseMatrixCSC{T, Int}
    A₁::SparseMatrixCSC{T, Int}
    A₂::SparseMatrixCSC{T, Int}
    fv::FacetValues
    dh::DofHandler
    cst::ConstraintHandler
    facetset
    dofsDtN
    N::Int64
    k
end

function (nep::Nnep{T})(α::T) where T
    # Allocate the TBC matrix
    F = allocate_stiff_matrix(nep.dh, nep.cst, nep.dofsDtN)

    # Assemble the TBC matrix 
    F = assemble_tbc(nep.fv, nep.dh, F, nep.facetset, nep.dofsDtN, nep.N, nep.k, α)
    
    # Impose the boundary conditions
    apply!(F, nep.cst)

    return nep.A₀ + α * nep.A₁ + (α^2) * nep.A₂ + F
end

function new_cim(ctr::Cim.AbstractContour, nep::Nnep, d::Int, l::Int; n=50, tol=1e-12)
    # Input validation
    d > 0 || throw(ArgumentError("d must be positive"))
    l > 0 || throw(ArgumentError("l must be positive"))

    # Get the quadrature points
    pts = get_quadpts(ctr, n)

    # Preallocate arrays
    A0 = zeros(ComplexF64, d, l)
    A1 = zeros(ComplexF64, d, l)
    Random.seed!(10);
    Vhat = randn(ComplexF64, d, l)

    # Compute A0 and A1 with trapezoid rule
    for j in 1:pts.N - 1
        z = complex(pts.nodes[j, 1], pts.nodes[j, 2])
        z_prime = complex(pts.nodes_prime[j, 1], pts.nodes_prime[j, 2])
        invNEP_Vhat = nep(z) \ Vhat
        A0 .+= invNEP_Vhat * z_prime
        A1 .+= invNEP_Vhat * z * z_prime
    end
    A0 ./= (im * (pts.N - 1))
    A1 ./= (im * (pts.N - 1))

    # Compute the SVD of A0
    (V, Sigma, W) = svd(A0)
    @show Sigma

    # Handle rank deficiency
    if isempty(Sigma)
        @warn "No eigenvalues found!"
        return ComplexF64[]
    end

    # Determine the number of nonzero singular values 
    k = count(Sigma ./ Sigma[1] .> tol)

    # Compute the matrix B 
    Vk = V[:,1:k]
    Sigk = Sigma[1:k]
    Wk = W[:,1:k]

    # Diagonal is more efficient
    B = (Vk' * A1 * Wk) * Diagonal(1 ./ Sigk)

    # Compute the eigenvalues of B 
    lambda = eigvals(B)

    # Avoid spurious eigenvalues
    filter!(λ -> Cim.is_inside(λ, ctr), lambda)

    return lambda
end